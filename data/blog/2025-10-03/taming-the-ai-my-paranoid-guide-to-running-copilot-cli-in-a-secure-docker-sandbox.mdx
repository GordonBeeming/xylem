---
title: 'Taming the AI: My Paranoid Guide to Running Copilot CLI in a Secure Docker Sandbox'
date: 2025-10-03
tags: ['Docker', 'GitHub', 'Copilot', 'Security', 'DevOps']
draft: false
summary: 'I love the new GitHub Copilot CLI, but as someone who is a little paranoid about security, I needed a way to use it with more confidence. Here''s how I built a secure, isolated Docker environment for it.'
---

ü§ù A Human-AI Collaboration - I worked with my AI assistant to bring this post to life. Think of it as a brainstorming partner that helps structure thoughts and smooth out the prose. The core message and the experience behind it? That's all me.

I love the new GitHub Copilot CLI. It feels like magic. But as someone who's a little paranoid about security, the idea of an AI having deep access to my terminal and file system made me... uneasy. üòÖ

The real power of the Copilot CLI comes from its ability to execute commands, but that requires a level of trust. I wanted the power of Copilot without giving it the keys to my entire kingdom. The goal was to use powerful features like `--allow-all-tools` with more confidence.

What if I could build a secure cage for it? A place where it can be helpful, but where its ability to cause chaos is strictly limited. So, I decided to put it in Docker.

## The "Why": My Wishlist for a Perfect Copilot Environment

Before diving in, I had a clear set of goals for what the ideal setup would look like:

* ‚úÖ **Secure Isolation:** The tool should only see the files in my current project directory. Nothing else.
* ‚úÖ **Auto-Authentication:** It must seamlessly use my existing `gh` login without any extra steps.
* ‚úÖ **Portability & Cleanliness:** No global Node.js or `npm` packages on my host machine.
* ‚úÖ **Cognitive Ease:** I want to *feel* safe enough to let it do its job, even if that means letting it run commands automatically.

## The Breakthrough: Why the Cage Makes the Tiger Safer

After a bit of trial and error (and a lot of debugging!), I landed on a solution that met all these goals. The core idea is to run Copilot inside a container, which dramatically reduces the "blast radius" of any potential mistakes.

You're probably thinking, "Wait, if it runs `rm -rf .`, won't that delete my code?" And you'd be absolutely right. It would.

The key difference is what "`.`" refers to. Inside the container, it would delete the contents of the `/work` directory, which is mapped to your **current project directory**. It can't touch your home directory, your SSH keys, or any other project folder. It's contained. Annoying? Yes. Catastrophic? No.

It's also important to note that this cage has open windows for network access. The container shares your host machine's network, so it's not a firewalled environment like a GitHub-hosted runner. This means if you have a secure local network, Copilot inherits that, but it can also access local resources, which is something to be aware of.

This isolation is what provides the **cognitive ease**. The container provides a strong safety net, which makes me optimistically more comfortable using a powerful but risky feature like `--allow-all-tools`. The risk isn't eliminated, but it's lowered to a level I'm comfortable with. For me, that trade-off is a worthy option.

<Figure key="/images/copilot-working-banner.png" src="/images/copilot-working-banner.png" alt="The final working Copilot CLI session, showing the banner and the logged-in user." width="0" height="0" caption="The final, working setup! It took a while to get here, but it was worth it." />

## The Final Setup: The Code

The complete solution is hosted on GitHub at [https://github.com/GordonBeeming/copilot_here](https://github.com/GordonBeeming/copilot_here). The setup consists of two files: a `Dockerfile` to build the environment and an `entrypoint.sh` script to handle user permissions.

Here's the `Dockerfile`:
```dockerfile
# Use a slim Node.js base image, which gives us `npm`.
FROM node:20-slim

# Set non-interactive frontend to avoid prompts during package installation.
ENV DEBIAN_FRONTEND=noninteractive

# Install git, curl, gpg, and gosu for the entrypoint script.
RUN apt-get update && apt-get install -y \
  curl \
  gpg \
  git \
  gosu \
  && rm -rf /var/lib/apt/lists/*

# ARG for the Copilot CLI version - passed from build process
# This ensures cache invalidation when a new version is available
ARG COPILOT_VERSION=latest

# Install the standalone GitHub Copilot CLI via npm.
RUN npm install -g @github/copilot@${COPILOT_VERSION}

# Set the working directory for the container.
WORKDIR /work

# Copy the entrypoint script into the container and make it executable.
COPY entrypoint.sh /usr/local/bin/
RUN chmod +x /usr/local/bin/entrypoint.sh

# Label for image cleanup
LABEL project="copilot_here"

# The entrypoint script will handle user creation and command execution.
ENTRYPOINT [ "entrypoint.sh" ]

# The default command to run if none is provided.
CMD [ "copilot", "--banner" ]
```

And the `entrypoint.sh` script:

```bash
#!/bin/bash
set -e

# Get the user and group IDs from environment variables, default to 1000 if not set.
USER_ID=${PUID:-1000}
GROUP_ID=${PGID:-1000}

# Create a group and user with the specified IDs.
groupadd --gid $GROUP_ID appuser_group >/dev/null 2>&1 || true
useradd --uid $USER_ID --gid $GROUP_ID --shell /bin/bash --create-home appuser >/dev/null 2>&1 || true

# Verify the user was created successfully
if ! id appuser >/dev/null 2>&1; then
    echo "Warning: Failed to create appuser, running as root" >&2
    mkdir -p /home/appuser/.copilot
    exec "$@"
fi

# Set up the .copilot directory and ensure ownership of the entire home dir.
mkdir -p /home/appuser/.copilot
chown -R $USER_ID:$GROUP_ID /home/appuser

# Switch to the new user and execute the command passed to the script.
exec gosu appuser "$@"
```

## Understanding the Modes and Features

The setup provides flexible options to match different workflows and security preferences.

### Execution Modes

**Safe Mode (`copilot_here`)** - Always asks for confirmation before executing commands. Recommended for general development work where you want control over what gets executed.

**YOLO Mode (`copilot_yolo`)** - Automatically approves all tool usage without confirmation. Convenient for trusted workflows but use with caution as it can execute commands without prompting.

### Image Variants

All functions support switching between Docker image variants using flags:
- **No flag** - Base image (Node.js, Git, basic tools)
- **`-d` or `--dotnet`** - .NET image (includes .NET 8 & 9 SDKs)
- **`-dp` or `--dotnet-playwright`** - .NET + Playwright image (includes browser automation)

### Additional Options

- **`-h` or `--help`** - Show usage help and examples (Bash/Zsh) or `-h` / `-Help` (PowerShell)
- **`--no-cleanup`** - Skip cleanup of unused Docker images (Bash/Zsh) or `-NoCleanup` (PowerShell)
- **`--no-pull`** - Skip pulling the latest image (Bash/Zsh) or `-NoPull` (PowerShell)

Both modes include security checks for proper GitHub token scopes and warn about overly privileged tokens. The functions also automatically clean up unused Docker images tagged with the project label, keeping your system tidy.

## Setup Instructions

The setup has been streamlined into single code blocks per platform, with both modes included in one installation.

### For Linux/macOS (Bash/Zsh)

Add the following functions to your shell profile (e.g., `~/.zshrc`, `~/.bashrc`):

```bash
# copilot_here shell functions
# Version: 2025-10-27
# Repository: https://github.com/GordonBeeming/copilot_here

# Helper function for security checks (shared by all variants)
__copilot_security_check() {
  if ! gh auth status 2>/dev/null | grep "Token scopes:" | grep -q "'copilot'"; then
    echo "‚ùå Error: Your gh token is missing the required 'copilot' scope."
    echo "Please run 'gh auth refresh -h github.com -s copilot' to add it."
    return 1
  fi

  if gh auth status 2>/dev/null | grep "Token scopes:" | grep -q -E "'(admin:|manage_|write:public_key|delete_repo|(write|delete)_packages)'"; then
    echo "‚ö†Ô∏è  Warning: Your GitHub token has highly privileged scopes (e.g., admin:org, admin:enterprise)."
    printf "Are you sure you want to proceed with this token? [y/N]: "
    read confirmation
    local lower_confirmation
    lower_confirmation=$(echo "$confirmation" | tr '[:upper:]' '[:lower:]')
    if [[ "$lower_confirmation" != "y" && "$lower_confirmation" != "yes" ]]; then
      echo "Operation cancelled by user."
      return 1
    fi
  fi
  return 0
}

# Helper function to cleanup unused copilot_here images
__copilot_cleanup_images() {
  local keep_image="$1"
  echo "üßπ Cleaning up unused copilot_here images..."
  
  # Get all copilot_here images with the project label
  local images_to_remove=$(docker images --filter "label=project=copilot_here" --format "{{.Repository}}:{{.Tag}}" | grep -v "^${keep_image}$" || true)
  
  if [ -z "$images_to_remove" ]; then
    echo "  ‚úì No unused images to clean up"
    return 0
  fi
  
  local count=0
  while IFS= read -r image; do
    if [ -n "$image" ]; then
      echo "  üóëÔ∏è  Removing: $image"
      docker rmi "$image" > /dev/null 2>&1 && ((count++)) || echo "  ‚ö†Ô∏è  Failed to remove: $image"
    fi
  done <<< "$images_to_remove"
  
  echo "  ‚úì Cleaned up $count image(s)"
}

# Helper function to pull image with spinner (shared by all variants)
__copilot_pull_image() {
  local image_name="$1"
  printf "üì• Pulling latest image: ${image_name}... "
  
  (docker pull "$image_name" > /dev/null 2>&1) &
  local pull_pid=$!
  local spin='|/-\'
  
  local i=0
  while ps -p $pull_pid > /dev/null; do
    i=$(( (i+1) % 4 ))
    printf "%s\b" "${spin:$i:1}"
    sleep 0.1
  done

  wait $pull_pid
  local pull_status=$?
  
  if [ $pull_status -eq 0 ]; then
    echo "‚úÖ"
    return 0
  else
    echo "‚ùå"
    echo "Error: Failed to pull the Docker image. Please check your Docker setup and network."
    return 1
  fi
}

# Core function to run copilot (shared by all variants)
__copilot_run() {
  local image_tag="$1"
  local allow_all_tools="$2"
  local skip_cleanup="$3"
  local skip_pull="$4"
  shift 4
  
  __copilot_security_check || return 1
  
  local image_name="ghcr.io/gordonbeeming/copilot_here:${image_tag}"
  
  echo "üöÄ Using image: ${image_name}"
  
  # Pull latest image unless skipped
  if [ "$skip_pull" != "true" ]; then
    __copilot_pull_image "$image_name" || return 1
  else
    echo "‚è≠Ô∏è  Skipping image pull"
  fi
  
  # Cleanup old images unless skipped
  if [ "$skip_cleanup" != "true" ]; then
    __copilot_cleanup_images "$image_name"
  else
    echo "‚è≠Ô∏è  Skipping image cleanup"
  fi

  local copilot_config_path="$HOME/.config/copilot-cli-docker"
  mkdir -p "$copilot_config_path"

  local token=$(gh auth token 2>/dev/null)
  if [ -z "$token" ]; then
    echo "‚ö†Ô∏è  Could not retrieve token using 'gh auth token'. Please ensure you are logged in."
  fi

  local docker_args=(
    --rm -it
    -v "$(pwd)":/work
    -v "$copilot_config_path":/home/appuser/.copilot
    -e PUID=$(id -u)
    -e PGID=$(id -g)
    -e GITHUB_TOKEN="$token"
    "$image_name"
  )

  local copilot_args=("copilot")
  if [ $# -eq 0 ]; then
    copilot_args+=("--banner")
  else
    copilot_args+=("-p" "$*")
  fi
  
  if [ "$allow_all_tools" = "true" ]; then
    copilot_args+=("--allow-all-tools")
  fi

  docker run "${docker_args[@]}" "${copilot_args[@]}"
}

# Safe Mode: Asks for confirmation before executing
copilot_here() {
  local image_tag="latest"
  local skip_cleanup="false"
  local skip_pull="false"
  local args=()
  
  # Parse arguments for image variant and control flags
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help)
        cat << 'EOF'
copilot_here - GitHub Copilot CLI in a secure Docker container (Safe Mode)

USAGE:
  copilot_here [OPTIONS] [PROMPT]

OPTIONS:
  -d, --dotnet              Use .NET image variant
  -dp, --dotnet-playwright  Use .NET + Playwright image variant
  --no-cleanup              Skip cleanup of unused Docker images
  --no-pull                 Skip pulling the latest image
  -h, --help                Show this help message

EXAMPLES:
  # Interactive mode
  copilot_here
  
  # Ask a question
  copilot_here "how do I list files in bash?"
  
  # Use .NET image
  copilot_here -d "build this .NET project"
  
  # Fast mode (skip cleanup and pull)
  copilot_here --no-cleanup --no-pull "quick question"

MODES:
  copilot_here  - Safe mode (asks for confirmation before executing)
  copilot_yolo  - YOLO mode (auto-approves all tool usage)

VERSION: 2025-10-27
REPOSITORY: https://github.com/GordonBeeming/copilot_here
EOF
        return 0
        ;;
      -d|--dotnet)
        image_tag="dotnet"
        shift
        ;;
      -dp|--dotnet-playwright)
        image_tag="dotnet-playwright"
        shift
        ;;
      --no-cleanup)
        skip_cleanup="true"
        shift
        ;;
      --no-pull)
        skip_pull="true"
        shift
        ;;
      *)
        args+=("$1")
        shift
        ;;
    esac
  done
  
  __copilot_run "$image_tag" "false" "$skip_cleanup" "$skip_pull" "${args[@]}"
}

# YOLO Mode: Auto-approves all tool usage
copilot_yolo() {
  local image_tag="latest"
  local skip_cleanup="false"
  local skip_pull="false"
  local args=()
  
  # Parse arguments for image variant and control flags
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help)
        cat << 'EOF'
copilot_yolo - GitHub Copilot CLI in a secure Docker container (YOLO Mode)

USAGE:
  copilot_yolo [OPTIONS] [PROMPT]

OPTIONS:
  -d, --dotnet              Use .NET image variant
  -dp, --dotnet-playwright  Use .NET + Playwright image variant
  --no-cleanup              Skip cleanup of unused Docker images
  --no-pull                 Skip pulling the latest image
  -h, --help                Show this help message

EXAMPLES:
  # Interactive mode (auto-approves all)
  copilot_yolo
  
  # Execute without confirmation
  copilot_yolo "run the tests and fix failures"
  
  # Use .NET + Playwright image
  copilot_yolo -dp "write playwright tests"
  
  # Fast mode (skip cleanup)
  copilot_yolo --no-cleanup "generate README"

WARNING:
  YOLO mode automatically approves ALL tool usage without confirmation.
  Use with caution and only in trusted environments.

MODES:
  copilot_here  - Safe mode (asks for confirmation before executing)
  copilot_yolo  - YOLO mode (auto-approves all tool usage)

VERSION: 2025-10-27
REPOSITORY: https://github.com/GordonBeeming/copilot_here
EOF
        return 0
        ;;
      -d|--dotnet)
        image_tag="dotnet"
        shift
        ;;
      -dp|--dotnet-playwright)
        image_tag="dotnet-playwright"
        shift
        ;;
      --no-cleanup)
        skip_cleanup="true"
        shift
        ;;
      --no-pull)
        skip_pull="true"
        shift
        ;;
      *)
        args+=("$1")
        shift
        ;;
    esac
  done
  
  __copilot_run "$image_tag" "true" "$skip_cleanup" "$skip_pull" "${args[@]}"
}
```

Then reload your shell (e.g., `source ~/.zshrc`).

### For Windows (PowerShell)

Save the following as `copilot_here.ps1` in a location of your choice (e.g., `C:\Users\YourName\Documents\PowerShell\`):

```powershell
# copilot_here PowerShell functions
# Version: 2025-10-27
# Repository: https://github.com/GordonBeeming/copilot_here

# Helper function for security checks (shared by all variants)
function Test-CopilotSecurityCheck {
    Write-Host "Verifying GitHub CLI authentication..."
    $authStatus = gh auth status 2>$null
    if (-not ($authStatus | Select-String -Quiet "'copilot'")) {
        Write-Host "‚ùå Error: Your gh token is missing the required 'copilot' scope." -ForegroundColor Red
        Write-Host "Please run 'gh auth refresh -h github.com -s copilot' to add it."
        return $false
    }

    $privilegedScopesPattern = "'(admin:|manage_|write:public_key|delete_repo|(write|delete)_packages)'"
    if ($authStatus | Select-String -Quiet $privilegedScopesPattern) {
        Write-Host "‚ö†Ô∏è  Warning: Your GitHub token has highly privileged scopes." -ForegroundColor Yellow
        $confirmation = Read-Host "Are you sure you want to proceed with this token? [y/N]"
        if ($confirmation.ToLower() -ne 'y' -and $confirmation.ToLower() -ne 'yes') {
            Write-Host "Operation cancelled by user."
            return $false
        }
    }
    Write-Host "‚úÖ Security checks passed."
    return $true
}

# Helper function to cleanup unused copilot_here images
function Remove-UnusedCopilotImages {
    param([string]$KeepImage)
    
    Write-Host "üßπ Cleaning up unused copilot_here images..."
    
    # Get all copilot_here images with the project label
    $allImages = docker images --filter "label=project=copilot_here" --format "{{.Repository}}:{{.Tag}}" 2>$null
    if (-not $allImages) {
        Write-Host "  ‚úì No unused images to clean up"
        return
    }
    
    $imagesToRemove = $allImages | Where-Object { $_ -ne $KeepImage }
    if (-not $imagesToRemove) {
        Write-Host "  ‚úì No unused images to clean up"
        return
    }
    
    $count = 0
    foreach ($image in $imagesToRemove) {
        Write-Host "  üóëÔ∏è  Removing: $image"
        $result = docker rmi $image 2>$null
        if ($LASTEXITCODE -eq 0) {
            $count++
        } else {
            Write-Host "  ‚ö†Ô∏è  Failed to remove: $image"
        }
    }
    
    Write-Host "  ‚úì Cleaned up $count image(s)"
}

# Helper function to pull image with spinner (shared by all variants)
function Get-CopilotImage {
    param([string]$ImageName)
    
    Write-Host -NoNewline "üì• Pulling latest image: ${ImageName}... "
    $pullJob = Start-Job -ScriptBlock { param($img) docker pull $img } -ArgumentList $ImageName
    $spinner = '|', '/', '-', '\'
    $i = 0
    while ($pullJob.State -eq 'Running') {
        Write-Host -NoNewline "$($spinner[$i])`b"
        $i = ($i + 1) % 4
        Start-Sleep -Milliseconds 100
    }

    Wait-Job $pullJob | Out-Null
    $pullOutput = Receive-Job $pullJob
    
    if ($pullJob.State -eq 'Completed') {
        Write-Host "‚úÖ"
        Remove-Job $pullJob
        return $true
    } else {
        Write-Host "‚ùå" -ForegroundColor Red
        Write-Host "Error: Failed to pull the Docker image." -ForegroundColor Red
        if (-not [string]::IsNullOrEmpty($pullOutput)) {
            Write-Host "Docker output:`n$pullOutput"
        }
        Remove-Job $pullJob
        return $false
    }
}

# Core function to run copilot (shared by all variants)
function Invoke-CopilotRun {
    param(
        [string]$ImageTag,
        [bool]$AllowAllTools,
        [bool]$SkipCleanup,
        [bool]$SkipPull,
        [string[]]$Arguments
    )
    
    if (-not (Test-CopilotSecurityCheck)) { return }
    
    $imageName = "ghcr.io/gordonbeeming/copilot_here:$ImageTag"
    
    Write-Host "üöÄ Using image: ${imageName}"
    
    # Pull latest image unless skipped
    if (-not $SkipPull) {
        if (-not (Get-CopilotImage -ImageName $imageName)) { return }
    } else {
        Write-Host "‚è≠Ô∏è  Skipping image pull"
    }
    
    # Cleanup old images unless skipped
    if (-not $SkipCleanup) {
        Remove-UnusedCopilotImages -KeepImage $imageName
    } else {
        Write-Host "‚è≠Ô∏è  Skipping image cleanup"
    }

    $copilotConfigPath = Join-Path $env:USERPROFILE ".config\copilot-cli-docker"
    if (-not (Test-Path $copilotConfigPath)) {
        New-Item -Path $copilotConfigPath -ItemType Directory -Force | Out-Null
    }

    $token = gh auth token 2>$null
    if ([string]::IsNullOrEmpty($token)) {
        Write-Host "‚ö†Ô∏è  Could not retrieve token using 'gh auth token'." -ForegroundColor Yellow
    }

    $dockerBaseArgs = @(
        "--rm", "-it",
        "-v", "$((Get-Location).Path):/work",
        "-v", "$($copilotConfigPath):/home/appuser/.copilot",
        "-e", "GITHUB_TOKEN=$token",
        $imageName
    )

    $copilotCommand = @("copilot")
    if ($Arguments.Length -eq 0) {
        $copilotCommand += "--banner"
    } else {
        $copilotCommand += "-p", ($Arguments -join ' ')
    }
    
    if ($AllowAllTools) {
        $copilotCommand += "--allow-all-tools"
    }

    $finalDockerArgs = $dockerBaseArgs + $copilotCommand
    docker run $finalDockerArgs
}

# Safe Mode: Asks for confirmation before executing
function Copilot-Here {
    [CmdletBinding()]
    param (
        [switch]$h,
        [switch]$Help,
        [switch]$d,
        [switch]$Dotnet,
        [switch]$dp,
        [switch]$DotnetPlaywright,
        [switch]$NoCleanup,
        [switch]$NoPull,
        [Parameter(ValueFromRemainingArguments=$true)]
        [string[]]$Prompt
    )

    if ($h -or $Help) {
        Write-Host @"
copilot_here - GitHub Copilot CLI in a secure Docker container (Safe Mode)

USAGE:
  copilot_here [OPTIONS] [PROMPT]

OPTIONS:
  -d, -Dotnet              Use .NET image variant
  -dp, -DotnetPlaywright   Use .NET + Playwright image variant
  -NoCleanup               Skip cleanup of unused Docker images
  -NoPull                  Skip pulling the latest image
  -h, -Help                Show this help message

EXAMPLES:
  # Interactive mode
  copilot_here
  
  # Ask a question
  copilot_here "how do I list files in PowerShell?"
  
  # Use .NET image
  copilot_here -d "build this .NET project"
  
  # Fast mode (skip cleanup and pull)
  copilot_here -NoCleanup -NoPull "quick question"

MODES:
  copilot_here  - Safe mode (asks for confirmation before executing)
  copilot_yolo  - YOLO mode (auto-approves all tool usage)

VERSION: 2025-10-27
REPOSITORY: https://github.com/GordonBeeming/copilot_here
"@
        return
    }

    $imageTag = "latest"
    if ($d -or $Dotnet) {
        $imageTag = "dotnet"
    } elseif ($dp -or $DotnetPlaywright) {
        $imageTag = "dotnet-playwright"
    }
    
    Invoke-CopilotRun -ImageTag $imageTag -AllowAllTools $false -SkipCleanup $NoCleanup -SkipPull $NoPull -Arguments $Prompt
}

# YOLO Mode: Auto-approves all tool usage
function Copilot-Yolo {
    [CmdletBinding()]
    param (
        [switch]$h,
        [switch]$Help,
        [switch]$d,
        [switch]$Dotnet,
        [switch]$dp,
        [switch]$DotnetPlaywright,
        [switch]$NoCleanup,
        [switch]$NoPull,
        [Parameter(ValueFromRemainingArguments=$true)]
        [string[]]$Prompt
    )

    if ($h -or $Help) {
        Write-Host @"
copilot_yolo - GitHub Copilot CLI in a secure Docker container (YOLO Mode)

USAGE:
  copilot_yolo [OPTIONS] [PROMPT]

OPTIONS:
  -d, -Dotnet              Use .NET image variant
  -dp, -DotnetPlaywright   Use .NET + Playwright image variant
  -NoCleanup               Skip cleanup of unused Docker images
  -NoPull                  Skip pulling the latest image
  -h, -Help                Show this help message

EXAMPLES:
  # Interactive mode (auto-approves all)
  copilot_yolo
  
  # Execute without confirmation
  copilot_yolo "run the tests and fix failures"
  
  # Use .NET + Playwright image
  copilot_yolo -dp "write playwright tests"
  
  # Fast mode (skip cleanup)
  copilot_yolo -NoCleanup "generate README"

WARNING:
  YOLO mode automatically approves ALL tool usage without confirmation.
  Use with caution and only in trusted environments.

MODES:
  copilot_here  - Safe mode (asks for confirmation before executing)
  copilot_yolo  - YOLO mode (auto-approves all tool usage)

VERSION: 2025-10-27
REPOSITORY: https://github.com/GordonBeeming/copilot_here
"@
        return
    }

    $imageTag = "latest"
    if ($d -or $Dotnet) {
        $imageTag = "dotnet"
    } elseif ($dp -or $DotnetPlaywright) {
        $imageTag = "dotnet-playwright"
    }
    
    Invoke-CopilotRun -ImageTag $imageTag -AllowAllTools $true -SkipCleanup $NoCleanup -SkipPull $NoPull -Arguments $Prompt
}

Set-Alias -Name copilot_here -Value Copilot-Here
Set-Alias -Name copilot_yolo -Value Copilot-Yolo
```

Add it to your PowerShell profile. Open your profile for editing:

```powershell
notepad $PROFILE
```

Add this line (adjust the path to where you saved the file):

```powershell
. C:\Users\YourName\Documents\PowerShell\copilot_here.ps1
```

Reload your PowerShell profile:

```powershell
. $PROFILE
```

## Usage

Once set up, using it is simple on any platform.

### Get Help

```bash
# Linux/macOS
copilot_here --help
copilot_yolo --help

# Windows
copilot_here -Help
copilot_yolo -Help
```

### Interactive Mode

Start a full chat session with the welcome banner:

```bash
# Base image (default)
copilot_here

# With .NET image
copilot_here -d

# With .NET + Playwright image
copilot_here -dp
```

### Non-Interactive Mode

Pass a prompt directly to get a quick response.

**Safe Mode** (asks for confirmation before executing):

```bash
# Base image
copilot_here "suggest a git command to view the last 5 commits"

# .NET image
copilot_here -d "build and test this .NET project"

# .NET + Playwright image
copilot_here -dp "run playwright tests for this app"

# Fast mode (skip cleanup and pull)
copilot_here --no-cleanup --no-pull "quick question"
```

**YOLO Mode** (auto-approves execution):

```bash
# Base image
copilot_yolo "write a function that reverses a string"

# .NET image
copilot_yolo -d "create a new ASP.NET Core API project"

# .NET + Playwright image
copilot_yolo -dp "write playwright tests for the login page"

# Fast mode (skip cleanup)
copilot_yolo --no-cleanup "generate README"
```

## Beyond the Basics: Specialized Docker Image Variants

As the project evolved, I realized that different development scenarios call for different tools. That's why I created specialized image variants that build on the secure foundation of the base image while adding language-specific capabilities.

### Available Image Variants

**Base Image (`latest`)**: The standard Copilot CLI environment with Node.js 20, Git, and essential tools. Perfect for general-purpose development and scripting.

**.NET Image (`dotnet`)**: Extends the base image with .NET 8.0 and 9.0 SDKs, along with ASP.NET Core runtimes and ICU libraries for internationalization support. Ideal for .NET development without the overhead of browser testing tools.

**.NET + Playwright Image (`dotnet-playwright`)**: The full-featured variant that includes everything from the .NET image plus Playwright 1.56.0 and Chromium browser with all dependencies. This is perfect for end-to-end testing and browser automation scenarios. Note that this image is approximately 500-600MB larger due to the Chromium binaries.

The beauty of the refactored setup is that you can switch between variants using simple flags like `-d` for .NET or `-dp` for .NET + Playwright, rather than manually editing image names.

### Automatic Cleanup

One of the newer features is automatic image cleanup. The functions now automatically remove unused `copilot_here` images (filtered by the `project=copilot_here` label) while keeping only the one you're currently using. This helps keep your Docker storage clean without manual intervention.

If you want to skip the cleanup for faster execution, use the `--no-cleanup` flag (or `-NoCleanup` on PowerShell). Similarly, you can skip pulling the latest image with `--no-pull` (or `-NoPull`) if you want even faster startup times.

## Conclusion: Security and Convenience Can Coexist

For me, this project is a perfect illustration of my standard playbook for adopting new command-line tools. Docker's power isn't just in deploying applications; its real magic for my daily workflow is creating these secure, ephemeral sandboxes.

This setup gives me the confidence to fully embrace what the Copilot CLI has to offer, without compromising my security posture. It doesn't mean my caution disappears entirely, I'll still keep a close eye on the configurations of the specific projects I run this in, but it provides a valuable safety net. In my own daily workflow, I have both versions installed: the default `copilot_here` for safe, everyday use, and `copilot_yolo` for when I'm working in a trusted project and value speed above all.

The specialized image variants add another layer of flexibility, allowing me to choose the right tool for the job. When I'm working on a .NET project, I can use the `dotnet` variant with a simple `-d` flag. When I need to run browser tests, the `dotnet-playwright` variant is just a `-dp` away.

The refactored setup with helper functions, automatic cleanup, and built-in help text makes the whole experience more polished and user-friendly. You can easily see what options are available with `--help`, and the system keeps itself tidy by cleaning up old images automatically.

Ultimately, this approach allows me to balance power with pragmatism, giving me the freedom to use powerful tools like `--allow-all-tools` with a level of comfort I wouldn't have otherwise. I hope it helps you too!

You can find all the source code for this project on my GitHub repo at [https://github.com/GordonBeeming/copilot_here](https://github.com/GordonBeeming/copilot_here). Give it a try and let me know what you think!
