---
title: 'Copilot CLI in Docker: October 2025 Updates - Auto-Updates, Cross-Platform Support, and More'
date: 2025-10-28
tags: ['Docker', 'GitHub Copilot', 'DevOps', 'Developer Experience', 'CLI Tools']
draft: false
summary: 'The October 2025 updates to copilot_here bring auto-updating scripts, full Windows support, argument pass-through for native Copilot features like --resume, smart image cleanup, and a bunch of quality-of-life improvements that make the Docker-based Copilot CLI experience even better.'
---

I've been running GitHub Copilot CLI in a Docker container for a while now (check out my [previous post](https://gordonbeeming.com/blog/2025-10-03/taming-the-ai-my-paranoid-guide-to-running-copilot-cli-in-a-secure-docker-sandbox) about the initial setup), and October 2025 brought a wave of improvements that transformed it from "works on my machine" to "works everywhere, smoothly."

## What's New in October 2025

Here's a quick summary of the major updates. Skip to any section that interests you:

1. **[Windows Docker Desktop Support](#1-windows-docker-desktop-support)** - Fixed user creation issues and made Windows a first-class platform
2. **[Auto-Updating Scripts](#2-auto-updating-scripts)** - One command to update your shell functions without manual copy-paste
3. **[Quick Install Method](#3-quick-install-method)** - Three commands instead of copying 200+ lines into your shell config
4. **[Argument Pass-Through](#4-argument-pass-through-unlocking-native-copilot-features)** - All native Copilot CLI features (like `--resume`) just work
5. **[Script Versioning](#5-script-versioning)** - Know exactly which version you're running
6. **[YOLO Mode Enhancements](#6-yolo-mode-enhancements)** - Auto-approve everything with `--allow-all-paths`
7. **[Smart Image Cleanup](#7-smart-image-cleanup)** - Only removes images older than 7 days, saves bandwidth and time

## 1. Windows Docker Desktop Support

### The "It Works On My Machine" Problem

You know that classic developer excuse? Well, it was literally true here. The Docker setup worked perfectly on my Mac... until someone tried it on Windows.

### The Issue

Windows Docker Desktop handles user creation differently than Linux. The container's entrypoint script was trying to create a non-root user (`appuser`) for security, but `useradd` was silently failing on Windows. The script would then try to switch to this non-existent user with `gosu`, and boom ðŸ’¥

```bash
error: failed switching to "appuser": unable to find user appuser: 
no matching entries in passwd file
```

### The Fix

Instead of just assuming user creation works, I added a verification step:

```bash
# Verify the user was created successfully
if ! id appuser >/dev/null 2>&1; then
    echo "Warning: Failed to create appuser, running as root" >&2
    mkdir -p /home/appuser/.copilot
    exec "$@"
fi
```

Is running as root in a local development container ideal? No. But it's a reasonable fallback for Windows users, and the warning message lets them know what's happening. Sometimes "works everywhere" beats "theoretically more secure but broken."

This also meant Windows needed to be a first-class citizen in the documentation, not an afterthought. So I restructured the entire README to show PowerShell instructions alongside bash/zsh, with equal prominence.

## 2. Auto-Updating Scripts

Here's a fun problem: the Docker image itself can auto-update via `docker pull`, but what about the shell functions users add to their `.bashrc` or `.zshrc`? Those live on the host machine.

### The Challenge

I wanted users to be able to update their shell functions without:
- Manually copying code from GitHub
- Re-running curl commands
- Editing their shell config files
- Accidentally breaking their setup

### The Solution

I created standalone script files (`copilot_here.sh` and `copilot_here.ps1`) that users can download once and source in their shell profiles. Then I added an `--update-scripts` flag that:

1. Downloads the latest version from GitHub
2. Shows you the version change
3. Automatically reloads your current shell session

```bash
copilot_here --update-scripts
```

Output:
```
Updating scripts from GitHub repository...
 Updated bash/zsh script
Current version: 2025-10-28
Reloading shell function...
 Scripts updated successfully!
```

The beauty is that it updates the file *and* reloads the function in your current session, so you don't even need to restart your terminal.

**Pro tip:** If you have the script symlinked somewhere (like a dotfiles repo), the update function detects the symlink and updates the source file. This way your dotfiles stay in sync automatically.

## 3. Quick Install Method

I had this elaborate setup where users needed to copy shell function code from the README and paste it into their config files. It worked, but it was clunky. Then I realized: why not just let them download and source a script file?

### Before (Manual Mode):
```bash
# User copies 200+ lines of bash from README
# Pastes into ~/.zshrc
# Hopes they got it all
# Maybe accidentally pastes twice
# Now has duplicate functions ðŸ˜¬
```

### After (Quick Install):
```bash
curl -fsSL https://raw.githubusercontent.com/GordonBeeming/copilot_here/main/copilot_here.sh -o ~/.copilot_here.sh
echo 'source ~/.copilot_here.sh' >> ~/.zshrc
source ~/.zshrc
```

Three commands. That's it. And because the script now lives in its own file, updating is as simple as `copilot_here --update-scripts`.

I also added duplicate detection, so if you accidentally run the setup twice, it won't add the source line multiple times:

```bash
if ! grep -q "source ~/.copilot_here.sh" ~/.zshrc 2>/dev/null; then
  echo 'source ~/.copilot_here.sh' >> ~/.zshrc
fi
```

## 4. Argument Pass-Through: Unlocking Native Copilot Features

Initially, I had built-in support for specific flags like `--help` and `--no-cleanup`. But what about all the other arguments that GitHub Copilot CLI supports?

I was basically re-implementing argument parsing for no reason. So I added automatic pass-through:

```bash
# Built-in wrapper args
WRAPPER_ARGS=("--help" "-h" "--no-cleanup" "--no-pull" "-d" "--dotnet" 
              "-dp" "--dotnet-playwright" "--update-scripts" "--upgrade-scripts")

# Check if arg is wrapper-specific or should pass through
for arg in "$@"; do
  if [[ ! " ${WRAPPER_ARGS[@]} " =~ " ${arg} " ]]; then
    # Not a wrapper arg, pass it to the container
    passthrough_args+=("$arg")
  fi
done
```

Now users can run any Copilot CLI command without me having to explicitly support it:

```bash
copilot_here --model gpt-4 "explain this code"
copilot_here -v  # Show version
copilot_here --whatever-future-flag-gets-added
```

### The --resume Flag: A Game Changer

One particularly useful feature this unlocks is the `--resume` flag. When Copilot is working through a multi-step task and something interrupts it (network hiccup, timeout, etc.), you can just resume right where it left off:

```bash
copilot_here --resume
```

<Figure key="copilot-resume-example" src="/images/copilot-resume-example.png" alt="Screenshot showing the --resume flag allowing continuation of a previous Copilot session" width="0" height="0" caption="The --resume flag picks up right where you left off" />

This is incredibly useful for long-running tasks where you don't want to start over from scratch. And because of the argument pass-through, it just worksâ€”no special handling needed on my end.

When you run `copilot_here --help`, it shows both the wrapper's help AND the underlying Copilot CLI help, so you can discover features like `--resume` naturally.

## 5. Script Versioning

One thing I learned from maintaining scripts in the wild: you need to know which version someone is running when they report an issue. So every script now has a version header:

```bash
# Version: 2025-10-28
```

The format is `YYYY-MM-DD` for the primary version, and if I make multiple updates in one day, it becomes `YYYY-MM-DD.1`, `YYYY-MM-DD.2`, etc.

This has already saved me multiple times when testing changes. Instead of "are you running the latest version?", I can say "you need version 2025-10-28 or later for that feature."

---

## 6. YOLO Mode Enhancements

One of the more fun additions was `copilot_yolo` mode. While `copilot_here` asks for confirmation before executing commands (safe, sensible), sometimes you just want to let Copilot do its thing without interruption:

```bash
copilot_yolo "fix all the linting errors in this project"
# Auto-approves all tool usage, including file modifications
```

I added a `--allow-all-paths` flag specifically for YOLO mode, which combines with auto-approval to create a fully automated experience. It's genuinely useful for trusted workflows, though I wouldn't recommend it for production systems ðŸ˜…

## 7. Smart Image Cleanup

One annoying thing that was happening: every time you ran `copilot_here`, it would clean up ALL unused images and then immediately pull the latest one again. Even if the latest one was literally the image you just removed. Talk about a waste of bandwidth and time.

### The Problem

The cleanup logic had two issues:

1. It was trying to remove intermediate images with `<none>` tags, which would fail and spam your console
2. It removed ALL unused images, including the current latest one, forcing an unnecessary re-download

```bash
  Failed to remove: ghcr.io/gordonbeeming/copilot_here:<none>
Pulling latest image...
# Downloads the same image it just removed ðŸ¤¦
```

### The Fix

Now the cleanup is smart:

```bash
# Get cutoff timestamp (7 days ago)
local cutoff_date=$(date -d '7 days ago' +%s 2>/dev/null || date -v-7d +%s 2>/dev/null)

# Get all copilot_here images, excluding <none> tags
local all_images=$(docker images --filter "label=project=copilot_here" \
  --format "{{.Repository}}:{{.Tag}}|{{.CreatedAt}}" | grep -v ":<none>" || true)

# Only remove if older than 7 days
if [ -n "$image_date" ] && [ "$image_date" -lt "$cutoff_date" ]; then
  docker rmi "$image" >/dev/null 2>&1
fi
```

Benefits:
- **Bandwidth savings**: Keeps the current image, no re-downloading
- **Time savings**: No unnecessary pulls on every launch
- **Disk space management**: Still cleans up old images after 7 days
- **No more errors**: `<none>` images are filtered out

The cleanup runs AFTER pulling the new image, so it can never remove what it just downloaded. Smart, right?

## Lessons Learned

### 1. **Cross-Platform Is Hard**
What works on macOS might fail spectacularly on Windows. Test early, test often, or at minimum make failure modes graceful.

### 2. **Auto-Update Everything**
If you can automate updates (Docker images, scripts, whatever), do it. Manual update processes are where software goes to die.

### 3. **Pass-Through > Re-Implementation**
Don't rebuild what already exists. Wrap it gracefully and get out of the way. This is how features like `--resume` just work without any extra code.

### 4. **Version Everything**
Future you (and your users) will thank you when debugging issues.

### 5. **Documentation Is A Product Feature**
Spend the time to make your README clear and comprehensive. It's often the only thing between users and frustration.

### 6. **Smart Defaults Beat Configuration**
Seven days for image cleanup is reasonable for most users. If someone needs different behavior, they can use `--no-cleanup`.

---

## What's Next?

The core functionality is solid now, but there are a few ideas I'm exploring:

- Better error messages when GitHub token scopes are wrong
- Support for custom Docker registries (for enterprise setups)
- Maybe a configurable cleanup period (though 7 days seems to work well)

But honestly? It works really well now. Sometimes the best feature is knowing when to stop adding features.

If you want to try it out, the project is on GitHub: [copilot_here](https://github.com/GordonBeeming/copilot_here)

The installation is literally three commands, and you'll have GitHub Copilot CLI running in a secure, sandboxed environment that stays up-to-date automatically. Give it a shot, and let me know what you think!

*Have questions or suggestions? Drop a comment below or open an issue on GitHub!*
