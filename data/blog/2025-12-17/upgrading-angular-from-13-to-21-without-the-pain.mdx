---
title: 'Upgrading Angular from 13 to 21 (Without the Pain)'
date: 2025-12-17
tags: ['GitHub Copilot', 'CLI Tools', 'Angular', 'AI', 'Developer Experience']
draft: false
summary: 'A practical, repeatable playbook for upgrading Angular major-by-major using GitHub Copilot CLI as your co-pilot: keep the app building at every step, fix the common breakpoints fast, and avoid the "big bang" upgrade trap.'
---

Upgrading Angular across **many major versions** used to be one of those tasks that quietly ruined a week.

Not because any single change is hard, but because the upgrade is death-by-a-thousand-cuts:

- installs break (peer deps, deprecated packages)
- build flag changes (`--prod` → configurations)
- compiler strictness increases
- build pipeline migrations (webpack → esbuild → application builder)
- deprecations finally becoming removals

This post is a practical playbook for doing it the *boring* way (in a good way): **major-by-major, build verified each step**—but with a twist: use **GitHub Copilot CLI** to do the work you'd normally do yourself.

Instead, I'll show a workflow you can apply to your own codebase, plus the kinds of fixes you'll hit along the way.

## The non-painful approach

The goal isn't "upgrade Angular". The goal is:

> **Make a change → get back to green → repeat.**

That's it.

When you upgrade from 13 → 21, you're not doing *one* upgrade. You're doing **eight** upgrades.

So treat it like a loop.

## What you need before you start

1. **A clean branch**
   - Create a dedicated branch, and ideally tag/commit at each major version.
2. **A single build command you trust**
   - For example:
     ```bash
     npm run build
     ```
   - If you have tests, even better:
     ```bash
     npm test
     ```
3. **A known-good Node toolchain**
   - Use `nvm` and pick a Node version that Angular supports.

## The workflow (human loop + AI accelerator)

Here's the loop I follow (and what I had Copilot CLI do for me).

### Step 0: Tell the AI what "done" means

You want the AI to behave like a senior engineer doing an upgrade: incremental, conservative, build-first.

Paste a prompt like this into Copilot CLI (this was tested with the GPT-5.2 model, but the structure matters more than the model):

```text
I need help upgrading an Angular app from v13 to v21.

Rules:
- Do upgrades one major version at a time.
- After each upgrade, run `npm run build` and fix whatever breaks.
- Make the smallest possible changes.
- If you need clarification, ask one question at a time.

Start by checking the current Angular version and identifying the Angular workspace.
```

A good agent will do exactly what you'd do:

- identify the workspace (`angular.json`)
- confirm versions
- plan the major-by-major upgrade path

### Step 1: Upgrade one major version

I like this pattern because it makes the CLI version explicit:

```bash
# Example: upgrade to Angular 14
npx -y -p @angular/cli@14 ng update @angular/core@14 @angular/cli@14 --force
npm install
npm run build
```

Repeat for 15, 16, 17… until you reach 21.

### Step 2: Fix what breaks (keep it scoped)

This is where Copilot CLI shines.

Normally, you'd:

1. read the error
2. search the codebase
3. apply the minimal fix
4. rebuild

With Copilot CLI, you can do the same steps… but you're not the one doing the typing, searching, and trial/error.

## The "upgrade breakpoints" you will hit

You won't hit all of these, but most Angular 13→21 upgrades hit a handful.

### 1) Deprecated/removed build flags

Example symptom:

```text
Unknown argument: prod
```

Fix:

```json
// package.json
{
  "scripts": {
    "build": "ng build --configuration production"
  }
}
```

### 2) Old dependencies that don't like modern Node

Common symptom:

- `node-sass` install failures

Fix:

```json
// package.json
{
  "devDependencies": {
    // remove node-sass
    // prefer sass
    "sass": "^1.x"
  }
}
```

### 3) The end of `entryComponents`

If you're coming from older Angular patterns, you might have modules like:

```ts
// app.module.ts
@NgModule({
  declarations: [...],
  entryComponents: [SomeDialogComponent]
})
export class AppModule {}
```

In modern Angular, `entryComponents` is gone.

Fix: delete the property.

### 4) Zone.js import changes

If your project still has old polyfill imports, you might hit errors like:

```text
"./dist/zone" is not exported from zone.js
```

Fix:

```ts
// polyfills.ts
import 'zone.js';
```

### 5) TypeScript/ESM import strictness

Modern Angular toolchains are pickier about import styles.

A common example is libraries that used to work with namespace imports:

```ts
import * as dayjs from 'dayjs';

const d = dayjs();
```

…and then suddenly don't.

Fix (default import):

```ts
import dayjs from 'dayjs';

const d = dayjs();
```

Same idea for plugin imports:

```ts
import relativeTime from 'dayjs/plugin/relativeTime';
dayjs.extend(relativeTime);
```

### 6) CSS import resolution changes (tilde `~`)

If you have older Sass imports like:

```scss
@import "~some-package/styles.css";
```

Modern tooling may not support the `~` resolver the same way.

Fix: remove the `~` and use package exports (or the documented import path).

### 7) New builder migrations and optional migrations

At some point, the CLI will offer migrations like:

- new build system / application builder
- template control flow syntax

My rule of thumb:

- **If you just want to finish the upgrade, accept the migration**.
- If you want minimal diffs, **skip optional migrations** and do them later.

## Why AI helps here (without "vibe coding" your app)

The key is that you're not asking the AI to "rewrite your app".

You're using it for:

- high-signal error triage
- targeted edits
- search-and-fix loops
- staying disciplined about *one change at a time*

That's the stuff that normally burns human hours.

### The framing that worked best

I got the best results when I made the constraints explicit:

- **incremental upgrades**
- **build after every step**
- **minimum change set**

If you don't tell the AI that, it will often try to "fix everything" at once.

## A repeatable checklist

Here's the copy/paste checklist I use:

1. `git checkout -b upgrade/angular-13-to-21`
2. For each major version:
   1. `npx -y -p @angular/cli@X ng update @angular/core@X @angular/cli@X --force`
   2. `npm install`
   3. `npm run build`
   4. Fix errors (minimal)
   5. Commit: `git commit -am "Upgrade Angular to X"`
3. Final pass:
   - `npx ng version`
   - run the build/test pipeline you rely on

## Closing thoughts

Angular upgrades are still work—but they don't have to be *painful* work.

If you keep the scope tight (major-by-major) and enlist Copilot CLI for the grind (search, triage, minimal fixes), you can get to the finish line dramatically faster while staying in control of your codebase.
